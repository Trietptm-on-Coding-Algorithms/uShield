/*

************************************
* Extended Exploitation Test (EET) *
************************************
(c) Jos Wetzels, Wouter Bokslag

Heap-based Buffer Overflow
Minimal heap-based b0f where the target is to overwrite a heap-stored function pointer (in order not to bother with details of heap-based b0f exploitation on various glibc versions).

Protections:
	XN
	Stack Cookies
	Full RELRO
	ASLR (host-enabled)

$ gcc -Bdynamic -lc -ldl -lrt -lm -lpthread -lgcc_s -fstack-protector-all -Wformat -Wformat-security -Wconversion -Wsign-conversion -Wl,-z,relro,-z,now -o heap_buffer_overflow heap_buffer_overflow.c

*/
#define _GNU_SOURCE

#define BUFFER_SIZE 4588
#define READ_SIZE (BUFFER_SIZE + 5)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <link.h>

extern uint32_t __stack_chk_guard;

struct _ptr_struct
{
	unsigned char data[BUFFER_SIZE];
	void* fptr;
};

typedef void display_f(char*);

void dummy_func(char* buffer)
{
	fprintf(stdout, "[%s]\n", buffer);
	fflush(stdout);
	return;
}

__attribute__ ((naked)) void pivot_gadget()
{
	asm volatile("mov sp, r0\n\t"
				 "pop {pc}"
				);
}

__attribute__ ((naked)) void arg_gadget()
{
  asm volatile("pop {r0, r1, r2, r3, lr}\n\t"
               "bx r3");
  return;
}

int infoleak_callback(struct dl_phdr_info *info, size_t size, void *data)
{
	fprintf(stdout, "[%s]@[%p]\n", info->dlpi_name, (void*)info->dlpi_addr);
	return 0;
}

void info_leak(void* p)
{
	uint32_t sp;

	asm volatile("mov %0, sp"
				 : "=r" (sp)
				);

	/* disclose stack pointer and stack cookie */
	fprintf(stdout, "[%04x.%04x]\n", sp, __stack_chk_guard);

	/* disclose loaded object base addresses */
	dl_iterate_phdr(infoleak_callback, NULL);

	fprintf(stdout, "[%p]\n", p);
	fprintf(stdout, "> ");
	fflush(stdout);

	return;
}

void vuln_func()
{	
	struct _ptr_struct* p;

	p = (struct _ptr_struct*)calloc(1, sizeof(struct _ptr_struct));

	info_leak((void*)p);

	p->fptr = (void*)dummy_func;

	/* heap-based buffer overflow */
	fgets(p->data, READ_SIZE, stdin);

	((display_f*)p->fptr)((char*)p->data);

	free(p);

	return;
}

int main(int argc, char* argv[])
{
	vuln_func();
}