/*

************************************
* Extended Exploitation Test (EET) *
************************************
(c) Jos Wetzels, Wouter Bokslag

Stack-based Buffer Overflow #1
Minimal stack-based b0f where the target is to overwrite the function return address on the stack.

Protections:
	XN
	Stack Cookies
	Full RELRO
	ASLR (host-enabled)

$ gcc -Bdynamic -lc -ldl -lrt -lm -lpthread -lgcc_s -fstack-protector-all -Wformat -Wformat-security -Wconversion -Wsign-conversion -Wl,-z,relro,-z,now -o stack_buffer_overflow_1 stack_buffer_overflow_1.c

*/
#define _GNU_SOURCE

#define PAYLOAD_SIZE 4588
#define BUFFER_SIZE 16
#define READ_SIZE (BUFFER_SIZE + PAYLOAD_SIZE)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <link.h>

extern uint32_t __stack_chk_guard;

int infoleak_callback(struct dl_phdr_info *info, size_t size, void *data)
{
	fprintf(stdout, "[%s]@[%p]\n", info->dlpi_name, (void*)info->dlpi_addr);
	return 0;
}

void info_leak()
{
	uint32_t sp;

	asm volatile("mov %0, sp"
				 : "=r" (sp)
				);

	/* disclose stack pointer and stack cookie */
	fprintf(stdout, "[%04x.%04x]\n", sp, __stack_chk_guard);

	/* disclose loaded object base addresses */
	dl_iterate_phdr(infoleak_callback, NULL);

	fprintf(stdout, "> ");
	fflush(stdout);

	return;
}

void vuln_func()
{	
	unsigned char buffer[BUFFER_SIZE] = {0};
	
	info_leak();

	/* stack-based buffer overflow */
	fgets(buffer, READ_SIZE, stdin);

	fprintf(stdout, "[%s]\n", buffer);
	fflush(stdout);

	return;
}

int main(int argc, char* argv[])
{
	vuln_func();
}