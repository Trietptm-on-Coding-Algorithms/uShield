/*

************************************
* Extended Exploitation Test (EET) *
************************************
(c) Jos Wetzels, Wouter Bokslag

Use-After-Free Vulnerability
Minimal use-after-free vulnerability where the target is to corrupt a function pointer

Protections:
	XN
	Stack Cookies
	Full RELRO
	ASLR (host-enabled)

$ gcc -Bdynamic -lc -ldl -lrt -lm -lpthread -lgcc_s -fstack-protector-all -Wformat -Wformat-security -Wconversion -Wsign-conversion -Wl,-z,relro,-z,now -o use_after_free use_after_free.c

*/
#define _GNU_SOURCE

#define BUFFER_SIZE1 4588
#define BUFFER_SIZE2 BUFFER_SIZE1 + 4
#define READ_SIZE1 BUFFER_SIZE1
#define READ_SIZE2 BUFFER_SIZE2

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <link.h>

extern uint32_t __stack_chk_guard;

int infoleak_callback(struct dl_phdr_info *info, size_t size, void *data)
{
	fprintf(stdout, "[%s]@[%p]\n", info->dlpi_name, (void*)info->dlpi_addr);
	return 0;
}

__attribute__ ((naked)) void pivot_gadget()
{
	asm volatile("add sp, r0, #4\n\t"
				 "pop {pc}"
				);
}

__attribute__ ((naked)) void arg_gadget()
{
  asm volatile("pop {r0, r1, r2, r3, lr}\n\t"
               "bx r3");
  return;
}

void info_leak()
{
	uint32_t sp;

	asm volatile("mov %0, sp"
				 : "=r" (sp)
				);

	/* disclose stack pointer and stack cookie */
	fprintf(stdout, "[%04x.%04x]\n", sp, __stack_chk_guard);

	/* disclose loaded object base addresses */
	dl_iterate_phdr(infoleak_callback, NULL);

	fprintf(stdout, "> ");
	fflush(stdout);

	return;
}

struct _obj1
{
	unsigned char data[BUFFER_SIZE1];
	void* fptr;
};

struct _obj2
{
	unsigned char data[BUFFER_SIZE2];
};

typedef void display_f(char*);

void dummy_func(char* buffer)
{
	fprintf(stdout, "[%s]\n", buffer);
	fflush(stdout);
	return;
}

struct _obj1* create_obj1(char* data)
{
	struct _obj1* obj1 = (struct _obj1*)calloc(1, sizeof(struct _obj1));
	
	if(obj1 == NULL)
	{
		return NULL;
	}

	memset(obj1->data, 0, BUFFER_SIZE1);
	memcpy(obj1->data, data, BUFFER_SIZE1);
	obj1->fptr = (void*)dummy_func;
	return obj1;
}

struct _obj2* create_obj2(char* data)
{
	struct _obj2* obj2 = (struct _obj2*)calloc(1, sizeof(struct _obj2));
	
	if(obj2 == NULL)
	{
		return NULL;
	}

	memset(obj2->data, 0, BUFFER_SIZE2);
	memcpy(obj2->data, data, BUFFER_SIZE2);
	return obj2;
}

void vuln_func()
{	
	unsigned char buffer[BUFFER_SIZE2 + 2] = {0};
	struct _obj1* obj1;
	struct _obj2* obj2;
	
	info_leak();

	fgets(buffer, READ_SIZE1 + 1, stdin);
	
	obj1 = create_obj1(buffer);

	/* leak heap object address */
	fprintf(stdout, "[%p]\n", obj1);
	fflush(stdout);

	/* info-leak in adjacent memory disclosing function pointer */
	((display_f*)obj1->fptr)((char*)obj1->data);

	fprintf(stdout, "> ");
	fflush(stdout);

	memset(buffer, 0, BUFFER_SIZE2 + 2);
	fgets(buffer, READ_SIZE2 + 1, stdin);

	free(obj1);
	obj2 = create_obj2(buffer);

	memset(buffer, 0, BUFFER_SIZE2 + 2);

	if (!strncmp(obj1->data, "FOO", 3))
	{
		/* use-after-free vulnerability */
		((display_f*)obj1->fptr)((char*)obj2->data);
	}

	free(obj2);

	return;
}

int main(int argc, char* argv[])
{
	vuln_func();
}