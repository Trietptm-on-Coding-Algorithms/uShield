/*

************************************
* Extended Exploitation Test (EET) *
************************************
(c) Jos Wetzels, Wouter Bokslag

Stack-based Buffer Overflow #2
Minimal stack-based b0f where the target is to overwrite a stack-stored function pointer.

Protections:
	XN
	Stack Cookies
	Full RELRO
	ASLR (host-enabled)

$ gcc -Bdynamic -lc -ldl -lrt -lm -lpthread -lgcc_s -fstack-protector-all -Wformat -Wformat-security -Wconversion -Wsign-conversion -Wl,-z,relro,-z,now -o stack_buffer_overflow_2 stack_buffer_overflow_2.c

*/
#define _GNU_SOURCE

#define PAYLOAD_SIZE 4588
#define BUFFER_SIZE 16
#define READ_SIZE (BUFFER_SIZE + PAYLOAD_SIZE)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <link.h>

extern uint32_t __stack_chk_guard;

int infoleak_callback(struct dl_phdr_info *info, size_t size, void *data)
{
	fprintf(stdout, "[%s]@[%p]\n", info->dlpi_name, (void*)info->dlpi_addr);
	return 0;
}

void info_leak()
{
	uint32_t sp;

	asm volatile("mov %0, sp"
				 : "=r" (sp)
				);

	/* disclose stack pointer and stack cookie */
	fprintf(stdout, "[%04x.%04x]\n", sp, __stack_chk_guard);

	/* disclose loaded object base addresses */
	dl_iterate_phdr(infoleak_callback, NULL);

	fprintf(stdout, "> ");
	fflush(stdout);

	return;
}

struct _ptr_struct
{
	unsigned char data[BUFFER_SIZE];
	void* fptr;
};

typedef void display_f(char*);

void dummy_func(char* buffer)
{
	fprintf(stdout, "[%s]\n", buffer);
	fflush(stdout);
	return;
}

void vuln_func(struct _ptr_struct* s)
{	
	s->fptr = (void*)dummy_func;
	
	info_leak();

	/* stack-based buffer overflow */
	fgets((char*)s->data, READ_SIZE, stdin);

	((display_f*)s->fptr)((char*)s->data);
	return;
}

int main(int argc, char* argv[])
{
	struct _ptr_struct s;
	
	memset(s.data, 0, BUFFER_SIZE);
	s.fptr = (void*)NULL;

	vuln_func(&s);
}