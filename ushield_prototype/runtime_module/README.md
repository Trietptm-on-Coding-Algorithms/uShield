# Runtime Protection Module (RPM): Installation & Usage Guide

----------

# Intro

The Runtime Protection Module (RPM) serves to implement the following elements of our protection proposal:

* *Shadow Stack (Backward-edge CFI)*: The RPM implements a lightweight parallel shadowstack for fully-precise backward-edge CFI.


* *Codepointer call heuristic validation (Relaxed forward-edge CFI)*: The RPM implements a lightweight and minimalist codepointer call heuristic validation to ensure dynamic function calls can only target legitimate function prologues thus ensuring a relaxed form of forward-edge CFI.

It effectively implements our 'advanced' level of protection.

The RPM logs its alerts to a preconfigured information logfile.

# Pre-Reqs

## Distro

Follow the distro setup steps in the environment setup guide.

# Installing and using the RPM

## Configuring the RPM

The first step of configuring the RPM is deciding on the configuration parameters:

```c
#define APP_NAME "test"

// Alert logging functionality
#define ALERT_LOG_FILE "/home/pi/prototype/rpm/alert_log"

// Policy measures (log, restart, kill)
#define DETECT_MEASURE MEASURE_LOG

// Enable forward-edge protection
#define FORWARD_EDGE_PROTECTION
// Enable backward-edge protection
#define BACKWARD_EDGE_PROTECTION

// Shadow stack size (in bytes), default is 4MB
#define SHADOW_STACK_SIZE (1024 * 1024 * 4)

// Instruction count threshold within which we have to find stackcookie setup
#define CPTR_PROLOGUE_COOKIE_THRESHOLD 25
```

The above configuration parameters relate to the protection mechanisms enabled and detection measures taken upon detecting an attack:

* `APP_NAME`: This is the target application's name which is currently hardcoded.
* `ALERT_LOG_FILE`: This is the name of the logfile where alerts will be logged to. Make sure it is writable.
* `DETECT_MEASURE`: This is the measure taken upon detecting an attack, currently only `MEASURE_LOG` (logging only, no further action) and `MEASURE_KILL` (terminate application after logging attack) are supported.
* `FORWARD_EDGE_PROTECTION`: This enables forward-edge protection (codepointer call validation).
* `BACKWARD_EDGE_PROTECTION`: This enables backward-edge protection (shadowstack).
* `SHADOW_STACK_SIZE`: This defines the size of the shadowstack. The default is 4MB but any size (as to be determined by the application engineer) is possible.
* `CPTR_PROLOGUE_COOKIE_THRESHOLD`: This is the maximum number of instructions within the prologue within which we expect to find the stackcookie setup fragment. Experientally we found `25` to be a suitable value.

Furthermore there are the `CEF` related constants which are elaborated upon in the KPM manual:

```c
/*
	CEF alert constants
*/
#define DEV_PLC 1
#define DEV_RTU 2
#define DEV_IED 3
#define DEV_PMU 4
#define DEV_PDC 5

#define CEF_TOOL_IP "192.168.0.102"
#define CEF_DVC_HOST "rpi"
#define CEF_VERSION 0
#define CEF_TOOL_ID 5
#define CEF_DEVICE_NUM DEV_PLC
#define CEF_TOOL_VERSION 1
#define CEF_EVENT_ID 1
#define CEF_EVENT_NAME "Exploitation of memory corruption vulnerability"
#define CEF_SEVERITY_LEVEL 7
```

Then there's the debug-related configuration data:

```c
//#define DEBUG_MODE

#ifdef DEBUG_MODE
	//#define DEBUG_MODE_INTERACTIVE
	//#define DEBUG_MODE_TECHNICAL
	#define DEBUG_MODE_VERBOSE
	//#define DEBUG_MODE_VERBOSE2

	#define debug_log(...) fprintf(stdout, __VA_ARGS__); fflush(stdout)
#endif

//#define SUPPRESS_ALERTS
//#define VERBOSE_ALERTS

#ifdef VERBOSE_ALERTS
	#define verbose_alert(...) fprintf(stdout, __VA_ARGS__); fflush(stdout)
#endif
```

Here we can toggle `DEBUG_MODE` (with various degrees of verbosity) and suppress alerts with `SUPPRESS_ALERTS`. We recommend that `DEBUG_MODE` is disabled and alerts are suppressed during performance overhead evaluation.

Finally there's the application-specific configuration file:

```c
#include "protect_config.h"
```

This file holds the relative addresses for instrumentation in hardcoded form (since implementing an XML parser is out-of-scope for an academic PoC) but this file is automatically generated by our setup module (see related documentation) and looks as follows:

```c
/*
	Hard-coded target addresses in lieu of configuration file parsing
*/

#define PROLOGUE_COUNT 6
#define EPILOGUE_COUNT 6
#define CPTRCALL_COUNT 2

arm_addr prologues[PROLOGUE_COUNT] = {0x414,0x600,0x64c,0x698,0x6e4,0x768};
arm_addr epilogues[EPILOGUE_COUNT] = {0x41c,0x640,0x68c,0x6d8,0x760,0x7d0};
arm_addr cptrcalls[CPTRCALL_COUNT] = {0x724,0x794};
```

## Building the RPM

Building the RPM is as simple as cd'ing to the appropriate directory and running:

```bash
gcc -Wall -fPIC -shared -o shield_rpm.so shield_rpm.c -ldl
```

## Starting the RPM

After it is built the RPM is started/loaded as follows given an application `test` which is to be protected:

```bash
LD_PRELOAD=./shield_rpm.so ./test
```

## Testing the RPM

When testing the RPM its debugging output is logged to stdout though one is free to modify the source to log to a dedicated debugfile instead.

As an example, consider the `test_clean` and `test_alert` applications included in this directory. Compile them as follows:

```bash
gcc -fno-omit-frame-pointer -Bdynamic -lc -ldl -lrt -lm -lpthread -lgcc_s -fstack-protector-all -Wformat -Wformat-security -Wconversion -Wsign-conversion -Wl,-z,relro,-z,now -o test_clean test_clean.c

gcc -fno-omit-frame-pointer -Bdynamic -lc -ldl -lrt -lm -lpthread -lgcc_s -fstack-protector-all -Wformat -Wformat-security -Wconversion -Wsign-conversion -Wl,-z,relro,-z,now -o test_alert test_alert.c
```

The first application is a simple hello world application with several codepointer calls and a recursive function to test the shadowstack and should not raise any alerts. The second application makes a codepointer call to a piece of shellcode and should trigger the codepointer call validation heuristic.

After compiling the applications, generate their respecitve `protect_config.h` files according to the setup module guide. Compile `shield_rpm.c` with the right configuration file and load it which gives (with debugging enabled) the following output:

```bash
$ cp testclean.h protect_config.h
$ gcc -Wall -fPIC -shared -o shield_rpm.so shield_rpm.c -ldl
$ LD_PRELOAD=./shield_rpm.so ./test_clean 
[*] Initializing Runtime Protection Module (RPM)...
[DEBUG] walker_callback: Found program image base address [0x10000]
[DEBUG] get_code_start_address: found program entrypoint [0x10470]
[DEBUG] get_code_start_address: found code start and end addresses at 0x10000 - 0x10814
[DEBUG] get_code_start_address: found program main() address [0x10768]
[DEBUG] get_code_start_address: scanning for stackcookie storage address in range [0x10470 - 0x107cc]
[DEBUG] get_code_start_address: found stack cookie address [0x21008]
[DEBUG] alloc_closest_free_area: Found free area of 1 pages in-range starting at address [0x11000]
[*] Setting up shadow stack initialization routine...
[*] Instrumenting prologues...
[*] Instrumenting epilogues...
[*] Instrumenting codepointer calls...
[+] Done instrumenting!
[DEBUG] walker_callback: Loaded object [./shield_rpm.so] @ [0xb6fb9000]
[DEBUG] walker_callback: Loaded object [/usr/lib/arm-linux-gnueabihf/libarmmem.so] @ [0xb6fa4000]
[DEBUG] walker_callback: Loaded object [/lib/arm-linux-gnueabihf/libc.so.6] @ [0xb6e63000]
[DEBUG] walker_callback: Loaded object [/lib/arm-linux-gnueabihf/libdl.so.2] @ [0xb6e50000]
[DEBUG] walker_callback: Loaded object [/lib/arm-linux-gnueabihf/librt.so.1] @ [0xb6e39000]
[DEBUG] walker_callback: Loaded object [/lib/arm-linux-gnueabihf/libm.so.6] @ [0xb6dbe000]
[DEBUG] walker_callback: Loaded object [/lib/arm-linux-gnueabihf/libpthread.so.0] @ [0xb6d96000]
[DEBUG] walker_callback: Loaded object [/lib/arm-linux-gnueabihf/libgcc_s.so.1] @ [0xb6d69000]
[DEBUG] walker_callback: Loaded object [/lib/ld-linux-armhf.so.3] @ [0xb6fcf000]
[+] Runtime Protection Module (RPM) installed!
[DEBUG] shadowstack_setup_handler: SP at 0xbefff7c0
[DEBUG] shadowstack_setup_handler: allocated shadowstack (4194304 bytes) at [0xb6968008 - 0xb6d68004], offset set to 82977bc
Hello!
World!
Goodbye!
[*] Removing Runtime Protection Module (RPM)...
[+] Uninstalled Runtime Protection Module (RPM)!

$ cp testalert.h protect_config.h
$ gcc -Wall -fPIC -shared -o shield_rpm.so shield_rpm.c -ldl
$ LD_PRELOAD=./shield_rpm.so ./test_alert 
[*] Initializing Runtime Protection Module (RPM)...
[DEBUG] walker_callback: Found program image base address [0x10000]
[DEBUG] get_code_start_address: found program entrypoint [0x10510]
[DEBUG] get_code_start_address: found code start and end addresses at 0x10000 - 0x10810
[DEBUG] get_code_start_address: found program main() address [0x1075c]
[DEBUG] get_code_start_address: scanning for stackcookie storage address in range [0x10510 - 0x107c0]
[DEBUG] get_code_start_address: found stack cookie address [0x21010]
[DEBUG] alloc_closest_free_area: Found free area of 1 pages in-range starting at address [0x11000]
[*] Setting up shadow stack initialization routine...
[*] Instrumenting prologues...
[*] Instrumenting epilogues...
[*] Instrumenting codepointer calls...
[+] Done instrumenting!
[DEBUG] walker_callback: Loaded object [./shield_rpm.so] @ [0xb6fb9000]
[DEBUG] walker_callback: Loaded object [/usr/lib/arm-linux-gnueabihf/libarmmem.so] @ [0xb6fa4000]
[DEBUG] walker_callback: Loaded object [/lib/arm-linux-gnueabihf/libc.so.6] @ [0xb6e63000]
[DEBUG] walker_callback: Loaded object [/lib/arm-linux-gnueabihf/libdl.so.2] @ [0xb6e50000]
[DEBUG] walker_callback: Loaded object [/lib/arm-linux-gnueabihf/librt.so.1] @ [0xb6e39000]
[DEBUG] walker_callback: Loaded object [/lib/arm-linux-gnueabihf/libm.so.6] @ [0xb6dbe000]
[DEBUG] walker_callback: Loaded object [/lib/arm-linux-gnueabihf/libpthread.so.0] @ [0xb6d96000]
[DEBUG] walker_callback: Loaded object [/lib/arm-linux-gnueabihf/libgcc_s.so.1] @ [0xb6d69000]
[DEBUG] walker_callback: Loaded object [/lib/ld-linux-armhf.so.3] @ [0xb6fcf000]
[+] Runtime Protection Module (RPM) installed!
[DEBUG] shadowstack_setup_handler: SP at 0xbefff7c0
[DEBUG] shadowstack_setup_handler: allocated shadowstack (4194304 bytes) at [0xb6968008 - 0xb6d68004], offset set to 82977bc
[!] ..:: [uShield RPM ALERT] ::..
[!] [1464220518 192.168.0.102 CEF:0 | 5 | 1 | 1 | 1 | Exploitation of memory corruption vulnerability | 7 | dvchost=rpi dvcpid=4367 deviceProcessName=test outcome=log message=Invalid codepointer call destination address (forward-edge violation) codepointer 0x107e4]
[!] raise_alert_handler: MEASURE_LOG activated!
$ id
uid=1000(pi) gid=1000(pi) groups=1000(pi)
```

As you can see an alert is raised and afterwards the payload is allowed to execute. This is a nice feature of the `MEASURE_LOG` detection measure which allows the payload to continue transparantly in its execution after raising an alert in order not to violate systems availability (which is crucial over integrity in our environment).